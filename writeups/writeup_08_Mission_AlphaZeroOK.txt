Write-up : Extraction du flag code{Vyb#Hq6y?e}

Contexte

On dispose du binaire ELF Mission_Lancement_Alpha_Zero (64 bits).

Objectif : retrouver un flag de 16 caractères.

0. Terrain de jeu

$ file Mission_Lancement_Alpha_Zero
Mission_Lancement_Alpha_Zero: ELF 64-bit LSB executable, x86-64, ...
$ chmod +x Mission_Lancement_Alpha_Zero
Un simple lancement sans argument :


$ ./Mission_Lancement_Alpha_Zero
[ … gros ASCII-art … ]
La fusee Astraeus IX est prete...
Bad Password!

1. Repérage visuel – strings + xxd

strings -td Mission_Lancement_Alpha_Zero | grep "Bad Password"

10499 Bad Password!

On veut voir ce qu’il y a après “Bad Password!” :


xxd -s $((10499 + 14)) -l 64 'Mission_Lancement_Alpha_Zero(2)'

00002911: 007c cc33 acf3 b444 9348 fc3f e1eb 3556  .|.3...D.H.?..5V
00002921: 206c 606b 6a74 3a6c 4840 3a75 7f2e 6479   l`kjt:lH@:u..dy
00002931: 721f a357 c988 e23d f16b b44e d792 0a33  r..W...=.k.N...3
00002941: 5d2c 0000 0002 0000 0000 0008 0000 0000  ],.............

Trois blocs de 16 octets juste à la suite : intéressant !

2. Vue rapide du code – objdump

$ objdump -d Mission_Lancement_Alpha_Zero | less

Pas besoin de tout décortiquer :
on voit quatre petites fonctions appelées après la lecture de l’entrée ;
la 1ère vérifie la longueur == 16,
les 3 autres manipulent un tampon (XOR / rotations) puis comparent aux 3 blocs.

3. Hypothèse & test dans Python
On soupçonne que deux blocs servent de clé/chiffrement pour le troisième (ou pour l’entrée).

Après avoir extrait deux blocs de 16 octets chacun dans la section .data du binaire, nous avons appliqué un XOR entre ces deux blocs (bloc1 ⊕ bloc3). 
Cette opération est réversible et permet ici de retrouver directement le flag caché. En effet, le développeur avait stocké une version chiffrée du flag à l'aide de cette méthode simple mais efficace.



Python script : 

from pathlib import Path

data = Path('Mission_Lancement_Alpha_Zero(2)').read_bytes()

offset = 10499 + 14   #Calcul de l'offset des blocs après "Bad Password!" :

bloc1 = data[offset : offset+16]
bloc2 = data[offset+16 : offset+32]
bloc3 = data[offset+32 : offset+48]

flag = bytes([a ^ c for a, c in zip(bloc1, bloc3)])
print(flag.decode())


résult : rcode{Vyb#Hq6y?e

16 octets, entièrement imprimables c'est surement le bon flag à quelques changements près.


Après avoir récupéré les 16 premiers caractères du flag en bloc1 ⊕ bloc3,
nous avons constaté qu'il manquait la dernière accolade } pour fermer correctement le format. Il faut également retiré le caractère 'r' tout au début.

Étant donné que la consigne du challenge précise que le flag fait 16 caractères, il est logique de tester en complétant avec une accolade fermante } pour valider l'ensemble.

good flag : code{Vyb#Hq6y?e}